"""Page de gestion des documents : upload, indexation, suppression."""
from __future__ import annotations

import os
import tempfile

import streamlit as st

from config import DOMAINS
from core.ingestion import delete_document, get_db_stats, ingest_directory, ingest_pdf
from utils.translations import t


def render_upload_page():
    """Affiche la page de gestion des documents."""
    domain = st.session_state.get("domain", "medical")
    collection_name = DOMAINS[domain]["collection"]
    doc_path = DOMAINS[domain]["doc_path"]

    st.header(t("page_upload"))
    st.info(t(f"upload_domain_hint_{domain}"))

    # Sync depuis dossier local
    if os.path.isdir(doc_path):
        if st.button(t("upload_sync_button"), type="primary"):
            with st.spinner(t("upload_sync_processing")):
                results = ingest_directory(doc_path, collection_name=collection_name)
            if results:
                total = sum(results.values())
                st.success(
                    f"{len(results)} {t('upload_sync_done')} ({total} chunks)"
                )
                for fname, n in results.items():
                    st.caption(f"  - {fname} ({n} chunks)")
                st.rerun()
            else:
                st.info(t("upload_sync_uptodate"))

    st.markdown("---")

    # Upload manuel
    uploaded_files = st.file_uploader(
        t("upload_help"),
        type=["pdf"],
        accept_multiple_files=True,
        key="pdf_uploader",
    )

    if uploaded_files:
        if st.button(t("upload_button"), type="primary"):
            total_chunks = 0
            progress = st.progress(0, text=t("upload_processing"))

            for i, uploaded_file in enumerate(uploaded_files):
                progress.progress(
                    (i) / len(uploaded_files),
                    text=f"{t('upload_processing')} {uploaded_file.name}",
                )

                with tempfile.NamedTemporaryFile(
                    delete=False, suffix=".pdf"
                ) as tmp:
                    tmp.write(uploaded_file.getvalue())
                    tmp_path = tmp.name

                try:
                    n_chunks = ingest_pdf(tmp_path, collection_name=collection_name)
                    total_chunks += n_chunks
                finally:
                    os.unlink(tmp_path)

            progress.progress(1.0, text=t("upload_done"))
            st.success(
                f"{len(uploaded_files)} {t('upload_success')} ({total_chunks} chunks)"
            )
            st.rerun()

    st.markdown("---")

    # Documents indexes
    stats = get_db_stats(collection_name=collection_name)
    if stats["sources"]:
        st.subheader(t("db_indexed_docs"))
        for source in stats["sources"]:
            col1, col2 = st.columns([4, 1])
            col1.write(f"ðŸ“„ {source}")
            if col2.button(
                t("upload_delete"), key=f"del_{source}", type="secondary"
            ):
                n = delete_document(source, collection_name=collection_name)
                st.toast(f"{source} {t('upload_deleted')} ({n} chunks)")
                st.rerun()
    else:
        st.info(t("no_documents"))
